# COMMENTED OUT - CI/CD Pipeline
# This workflow has been temporarily disabled to focus on specialized workflows
# Uncomment when needed for CI/CD pipeline functionality

#name: CI/CD Pipeline
#
#on:
#  push:
#    branches: [ main, develop ]
#  pull_request:
#    branches: [ main ]
#  release:
#    types: [ published ]
#
#env:
#  REGISTRY: ghcr.io
#  IMAGE_NAME_MCP: ${{ github.repository }}/mcp-server
#  IMAGE_NAME_STREAMLIT: ${{ github.repository }}/streamlit-app
#
#jobs:
#  # Lightweight validation for CI/CD pipeline
#  validate:
#    name: CI/CD Validation
#    runs-on: ubuntu-latest
#    
#    steps:
#    - name: Checkout code
#      uses: actions/checkout@v4
#    
#    - name: Set up Python
#      uses: actions/setup-python@v4
#      with:
#        python-version: '3.11'
#    
#    - name: Cache pip dependencies
#      uses: actions/cache@v3
#      with:
#        path: ~/.cache/pip
#        key: ${{ runner.os }}-cicd-pip-${{ hashFiles('**/requirements*.txt') }}
#        restore-keys: |
#          ${{ runner.os }}-cicd-pip-
#    
#    - name: Install minimal dependencies
#      run: |
#        python -m pip install --upgrade pip
#        pip install -r requirements.txt
#    
#    - name: Validate CI/CD readiness
#      run: |
#        echo "ðŸ” Validating CI/CD pipeline readiness..."
#        
#        # Check if main application can be imported
#        python -c "import src.sonarqube_mcp.server; print('âœ… MCP Server module imports successfully')"
#        
#        # Check if required files exist for deployment
#        if [ -f "requirements.txt" ]; then
#          echo "âœ… requirements.txt found"
#        else
#          echo "âŒ requirements.txt missing"
#          exit 1
#        fi
#        
#        # Validate Docker files exist (if any)
#        if find . -name "Dockerfile*" -o -name "docker-compose*.yml" | grep -q .; then
#          echo "âœ… Docker files found - ready for containerization"
#        else
#          echo "â„¹ï¸ No Docker files found - containerization not configured"
#        fi
#        
#        # Check for Kubernetes manifests (if any)
#        if find . -name "*.yaml" -path "*/k8s/*" | grep -q .; then
#          echo "âœ… Kubernetes manifests found - ready for K8s deployment"
#        else
#          echo "â„¹ï¸ No Kubernetes manifests found - K8s deployment not configured"
#        fi
#        
#        echo "âœ… CI/CD validation completed"
#
#  # Deployment readiness check
#  deployment-readiness:
#    name: Deployment Readiness Check
#    runs-on: ubuntu-latest
#    needs: validate
#    if: github.ref == 'refs/heads/main' || github.event_name == 'release'
#    
#    steps:
#    - name: Checkout code
#      uses: actions/checkout@v4
#    
#    - name: Check deployment prerequisites
#      run: |
#        echo "ðŸ” Checking deployment prerequisites..."
#        
#        # Check for environment-specific configurations
#        MISSING_CONFIGS=()
#        
#        # Check for secrets documentation
#        if [ ! -f "docs/deployment/secrets.md" ] && [ ! -f "DEPLOYMENT.md" ]; then
#          MISSING_CONFIGS+=("deployment documentation")
#        fi
#        
#        # Check for health check endpoints
#        if ! grep -r "health" src/ --include="*.py" | grep -q "def.*health"; then
#          MISSING_CONFIGS+=("health check endpoint")
#        fi
#        
#        # Report findings
#        if [ ${#MISSING_CONFIGS[@]} -eq 0 ]; then
#          echo "âœ… All deployment prerequisites met"
#        else
#          echo "âš ï¸ Missing deployment prerequisites:"
#          for config in "${MISSING_CONFIGS[@]}"; do
#            echo "  - $config"
#          done
#          echo ""
#          echo "â„¹ï¸ These are recommendations, not blockers"
#        fi
#        
#        echo "âœ… Deployment readiness check completed"
#
#    - name: Generate deployment summary
#      run: |
#        echo "# Deployment Readiness Summary" > deployment-readiness.md
#        echo "Generated on: $(date)" >> deployment-readiness.md
#        echo "" >> deployment-readiness.md
#        echo "## Status" >> deployment-readiness.md
#        echo "- âœ… Basic validation passed" >> deployment-readiness.md
#        echo "- âœ… Application imports successfully" >> deployment-readiness.md
#        echo "- âœ… Required files present" >> deployment-readiness.md
#        echo "" >> deployment-readiness.md
#        echo "## Next Steps" >> deployment-readiness.md
#        echo "1. Configure container registry credentials" >> deployment-readiness.md
#        echo "2. Set up deployment environment secrets" >> deployment-readiness.md
#        echo "3. Configure monitoring and logging" >> deployment-readiness.md
#        echo "4. Set up health checks and readiness probes" >> deployment-readiness.md
#        echo "" >> deployment-readiness.md
#        echo "## Notes" >> deployment-readiness.md
#        echo "- For security analysis, see specialized SAST workflows" >> deployment-readiness.md
#        echo "- For quality analysis, see specialized quality workflows" >> deployment-readiness.md
#        echo "- For comprehensive testing, see main CI workflow" >> deployment-readiness.md
#    
#    - name: Upload deployment readiness report
#      uses: actions/upload-artifact@v3
#      with:
#        name: deployment-readiness-report
#        path: deployment-readiness.md

  # Build Docker Images - COMMENTED OUT FOR NOW
  # build-images:
  #   name: Build Docker Images
  #   runs-on: ubuntu-latest
  #   needs: [test, security-scan]
  #   if: github.event_name != 'pull_request'
  #   
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4
  #   
  #   - name: Set up Docker Buildx
  #     uses: docker/setup-buildx-action@v3
  #   
  #   - name: Log in to Container Registry
  #     uses: docker/login-action@v3
  #     with:
  #       registry: ${{ env.REGISTRY }}
  #       username: ${{ github.actor }}
  #       password: ${{ secrets.GITHUB_TOKEN }}
  #   
  #   - name: Extract metadata for MCP Server
  #     id: meta-mcp
  #     uses: docker/metadata-action@v5
  #     with:
  #       images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_MCP }}
  #       tags: |
  #         type=ref,event=branch
  #         type=ref,event=pr
  #         type=semver,pattern={{version}}
  #         type=semver,pattern={{major}}.{{minor}}
  #         type=sha,prefix={{branch}}-
  #   
  #   - name: Extract metadata for Streamlit App
  #     id: meta-streamlit
  #     uses: docker/metadata-action@v5
  #     with:
  #       images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_STREAMLIT }}
  #       tags: |
  #         type=ref,event=branch
  #         type=ref,event=pr
  #         type=semver,pattern={{version}}
  #         type=semver,pattern={{major}}.{{minor}}
  #         type=sha,prefix={{branch}}-
  #   
  #   - name: Build and push MCP Server image
  #     uses: docker/build-push-action@v5
  #     with:
  #       context: .
  #       file: ./docker/dockerfiles/mcp-server.Dockerfile
  #       push: true
  #       tags: ${{ steps.meta-mcp.outputs.tags }}
  #       labels: ${{ steps.meta-mcp.outputs.labels }}
  #       cache-from: type=gha
  #       cache-to: type=gha,mode=max
  #       platforms: linux/amd64,linux/arm64
  #   
  #   - name: Build and push Streamlit App image
  #     uses: docker/build-push-action@v5
  #     with:
  #       context: .
  #       file: ./docker/dockerfiles/streamlit.Dockerfile
  #       push: true
  #       tags: ${{ steps.meta-streamlit.outputs.tags }}
  #       labels: ${{ steps.meta-streamlit.outputs.labels }}
  #       cache-from: type=gha
  #       cache-to: type=gha,mode=max
  #       platforms: linux/amd64,linux/arm64
  #   
  #   - name: Run Trivy vulnerability scanner on images
  #     run: |
  #       docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  #         aquasec/trivy image --format sarif --output mcp-server-trivy.sarif \
  #         ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_MCP }}:${{ github.sha }}
  #       
  #       docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  #         aquasec/trivy image --format sarif --output streamlit-app-trivy.sarif \
  #         ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_STREAMLIT }}:${{ github.sha }}
  #   
  #   - name: Upload image scan results
  #     uses: actions/upload-artifact@v3
  #     with:
  #       name: image-security-reports
  #       path: |
  #         mcp-server-trivy.sarif
  #         streamlit-app-trivy.sarif

  # Deploy to Staging - COMMENTED OUT FOR NOW
  # deploy-staging:
  #   name: Deploy to Staging
  #   runs-on: ubuntu-latest
  #   needs: [test, security-scan] # Removed build-images dependency
  #   if: github.ref == 'refs/heads/develop'
  #   environment: staging
  #   
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4
  #   
  #   - name: Set up kubectl
  #     uses: azure/setup-kubectl@v3
  #     with:
  #       version: 'v1.28.0'
  #   
  #   - name: Configure kubectl
  #     run: |
  #       echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig
  #       export KUBECONFIG=kubeconfig
  #   
  #   - name: Deploy to staging
  #     run: |
  #       export KUBECONFIG=kubeconfig
  #       
  #       # Update image tags in manifests
  #       sed -i "s|sonarqube-mcp/mcp-server:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME_MCP }}:develop-${{ github.sha }}|g" k8s/mcp-server.yaml
  #       sed -i "s|sonarqube-mcp/streamlit-app:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME_STREAMLIT }}:develop-${{ github.sha }}|g" k8s/streamlit-app.yaml
  #       
  #       # Apply manifests
  #       kubectl apply -f k8s/namespace.yaml
  #       kubectl apply -f k8s/secrets.yaml
  #       kubectl apply -f k8s/postgres.yaml
  #       kubectl apply -f k8s/redis.yaml
  #       kubectl apply -f k8s/sonarqube.yaml
  #       kubectl apply -f k8s/mcp-server.yaml
  #       kubectl apply -f k8s/streamlit-app.yaml
  #       kubectl apply -f k8s/monitoring/
  #       
  #       # Wait for deployment
  #       kubectl rollout status deployment/mcp-server -n sonarqube-mcp --timeout=300s
  #       kubectl rollout status deployment/streamlit-app -n sonarqube-mcp --timeout=300s
  #   
  #   - name: Run smoke tests
  #     run: |
  #       export KUBECONFIG=kubeconfig
  #       
  #       # Wait for services to be ready
  #       kubectl wait --for=condition=ready pod -l app=mcp-server -n sonarqube-mcp --timeout=300s
  #       kubectl wait --for=condition=ready pod -l app=streamlit-app -n sonarqube-mcp --timeout=300s
  #       
  #       # Run basic health checks
  #       kubectl port-forward svc/mcp-server-service 8001:8001 -n sonarqube-mcp &
  #       sleep 10
  #       curl -f http://localhost:8001/health || exit 1
  #       
  #       kubectl port-forward svc/streamlit-app-service 8501:8501 -n sonarqube-mcp &
  #       sleep 10
  #       curl -f http://localhost:8501/_stcore/health || exit 1

  # Deploy to Production - COMMENTED OUT FOR NOW
  # deploy-production:
  #   name: Deploy to Production
  #   runs-on: ubuntu-latest
  #   needs: [test, security-scan] # Removed build-images dependency
  #   if: github.event_name == 'release'
  #   environment: production
  #   
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4
  #   
  #   - name: Set up kubectl
  #     uses: azure/setup-kubectl@v3
  #     with:
  #       version: 'v1.28.0'
  #   
  #   - name: Configure kubectl
  #     run: |
  #       echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
  #       export KUBECONFIG=kubeconfig
  #   
  #   - name: Deploy to production
  #     run: |
  #       export KUBECONFIG=kubeconfig
  #       
  #       # Update image tags in manifests
  #       sed -i "s|sonarqube-mcp/mcp-server:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME_MCP }}:${{ github.event.release.tag_name }}|g" k8s/mcp-server.yaml
  #       sed -i "s|sonarqube-mcp/streamlit-app:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME_STREAMLIT }}:${{ github.event.release.tag_name }}|g" k8s/streamlit-app.yaml
  #       
  #       # Apply manifests with rolling update
  #       kubectl apply -f k8s/namespace.yaml
  #       kubectl apply -f k8s/secrets.yaml
  #       kubectl apply -f k8s/postgres.yaml
  #       kubectl apply -f k8s/redis.yaml
  #       kubectl apply -f k8s/sonarqube.yaml
  #       kubectl apply -f k8s/mcp-server.yaml
  #       kubectl apply -f k8s/streamlit-app.yaml
  #       kubectl apply -f k8s/ingress.yaml
  #       kubectl apply -f k8s/monitoring/
  #       
  #       # Wait for deployment
  #       kubectl rollout status deployment/mcp-server -n sonarqube-mcp --timeout=600s
  #       kubectl rollout status deployment/streamlit-app -n sonarqube-mcp --timeout=600s
  #   
  #   - name: Run production health checks
  #     run: |
  #       export KUBECONFIG=kubeconfig
  #       
  #       # Wait for services to be ready
  #       kubectl wait --for=condition=ready pod -l app=mcp-server -n sonarqube-mcp --timeout=600s
  #       kubectl wait --for=condition=ready pod -l app=streamlit-app -n sonarqube-mcp --timeout=600s
  #       
  #       # Verify ingress is working
  #       sleep 30
  #       curl -f https://api.sonarqube-mcp.yourdomain.com/health || exit 1
  #       curl -f https://sonarqube-mcp.yourdomain.com/_stcore/health || exit 1
  #   
  #   - name: Notify deployment success
  #     uses: 8398a7/action-slack@v3
  #     with:
  #       status: success
  #       text: 'Production deployment successful! ðŸš€'
  #     env:
  #       SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Cleanup - COMMENTED OUT FOR NOW
  # cleanup:
  #   name: Cleanup
  #   runs-on: ubuntu-latest
  #   needs: [deploy-staging, deploy-production]
  #   if: always()
  #   
  #   steps:
  #   - name: Clean up old images
  #     run: |
  #       # This would typically clean up old container images
  #       # Implementation depends on your registry cleanup policies
  #       echo "Cleanup completed"